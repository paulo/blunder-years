\documentclass[a4paper,10pt]{report}

\usepackage{graphicx}
\usepackage{color}

\usepackage{caption}
\usepackage{subcaption}

\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{geometry}
\geometry{a4paper}
\usepackage[parfill]{parskip}

\usepackage{changepage}

\usepackage{amsmath}

\usepackage{fancyhdr}

\usepackage{nopageno}

\graphicspath{{./imagens/}}

\usepackage{url}

\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{float}

\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue]{hyperref}


\lstset{
    extendedchars=\true,
    inputencoding=utf8
}

\renewcommand{\lstlistingname}{Código}
\usepackage{color}
\definecolor{grey}{rgb}{0.9,0.9,0.9}
\definecolor{greyD}{rgb}{0.5,0.5,0.5}

\lstnewenvironment{code}[1][]%
{
   \noindent
   \lstset{
  float=htpb,
  backgroundcolor=\color{grey},
  basicstyle=\scriptsize,
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{greyD},
  breaklines=true,
  frame=single,
  #1}
}
{}

\begin{document}

\include{capa}

\begin{abstract}
Este relatório descreve o desenvolvimento de um compilador para uma linguagem de programação simples (lps). 

A linguagem desenvolvida foi baseada no C, e suporta:
\begin{itemize}
  \item Variáveis globais
  \item Ciclos: for, while, do while
  \item Estruturas de Condição: If .. Else
  \item Expressões Aritméticas e lógicas
  \item Funções com argumentos
  \item Declaração de variáveis locais dentro das funções
\end{itemize}
O compilador foi desenvolvido com recurso ao analisador léxico Flex e ao analisador sintático Yacc.

\end{abstract}
%----------------------------------------------------------------------
%\newpage
%\phantom{placeholder} % doesn't appear on page
%\thispagestyle{empty} % if want no header/footer
%----------------------------------------------------------------------
\tableofcontents
%\phantom{placeholder} % doesn't appear on page
\thispagestyle{empty} % if want no header/footer
%----------------------------------------------------------------------
%\newpage
%\phantom{placeholder} % doesn't appear on page
%\thispagestyle{empty} % if want no header/footer
%----------------------------------------------------------------------
%\pagestyle{fancy}
%\setlength{\headheight}{15.2pt}
%\fancyhf{} % apagar as configurações actuais
%\fancyfoot[LE,RO]{\thepage}
%\fancyhead[LE,RO]{PL - Trabalho Pratico 1 --- Araujo P., Belo O., Oliveira R.}
%\page{setcounter}{0}
%----------------------------------------------------------------------

\chapter{Introdução}
\label{cap:intro}
O presente trabalho enquadra-se na unidade curricular de Processamento de Linguangens da Licenciatura em Engenharia Informática da Universidade do Minho. O trabalho pretende aumentar a experiência em engenharia de linguagens, 

\section{Linguagem de programação imperativa simples}
    Previamente ao desenvolvimento do compilador existe a necessidade de definir uma linguagem sobre a qual este atua, com base numa qualquer linguagem imperativa. Neste sentido e por simplicidade e familiaridade, a linguagem de programação C é a selecionada. Esta linguagem foi simplificada por forma a adaptar-se aos requisitos propostos, sofrendo as seguinte modificações na sua estrutura:

    - Apenas permite manusear variáveis do tipo inteiro (escalar ou array).
    - Suporta apenas as instruções vulgares de controlo de fluxo de execução (condicional e cíclica), tais como if-else, for, while e do-while.
    - As instruções que controlam inserção e output de valores (tipicamente printf e scanf) estão adaptadas para suportar apenas inteiros, e então estão renomeadas (printi e scani).
    - As expressões lógicas devem estar rodeadas por parentises para facilitar a sua distinção e ordem quando em conjunto com expressões aritméticas. 


    <Programa exemplo (programa exemplo que mostre de forma simples todas as funcionalidades - funçoes, atribuiçoes, ciclos, expressoes logicas e aritmeticas)> 

\section{Arquitetura}
    O sistema desenvolvido é principalmente constituído por 2 modelos:  parser.l, compiler.y, que são respetivamente o analisador léxico e analisador sintático. 

    Na Figura \ref{fig:dependencias}, podemos observar as dependências entre os ficheiros.

    O analisador sintático utiliza o ficheiro vmCompiler.h, sendo que este o modulo responsável pelo tratamento das variáveis e funções existentes (adicionar/consultar variáveis).

    O Sistema utiliza também duas estruturas de dados: uma HashMap e uma Stack. A hashmap é utilizada respetivamente para guardar as variáveis e as funções, enquanto que a stack permite o controlo das labels dos ciclos durante a compilação.

    Na figura \ref{fig:struct} é possível observar as estruturas utilizadas em vmCompiler:
    \begin{itemize}
      \item Scope - possuem uma map com a informação das variáveis, onde a chave é nome da variável e o valor é um EntryVar;
      \item EntryFun - guarda a informação sobre o tipo de uma função (argumentos de entrada e tipo de retorno);
      \item EntryVar - guarda o tipo, nome o endereço relativo de uma dada variável;
    \end{itemize}

    Com as estruturas anteriores em mente, as variáveis criadas em vmCompiler são as representadas na figura \ref{fig:objs}, onde se podem ver duas variáveis do tipo Scope, uma para o contexto global e outra para o contexto interior a uma função.

    Existe um map de EntryFun (mFuncMap) onde a chave é o nome da função.
    
    A variável DecFunAux consiste num apontador temporário para uma função declarada.

\begin{figure}
\centering
\includegraphics[width=15cm]{imagens/dependecias.png}
\caption{Diagrama das pedendencias dos ficheiros}
\label{fig:dependencias}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=10cm]{imagens/estruturas.jpg}
\caption{Diagrama das estruturas usadas em vmCompiler}
\label{fig:struct}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=10cm]{imagens/objetos.jpg}
\caption{Diagrama dos objetos existente em vmCompiler}
\label{fig:objs}
\end{figure}



\section{Estruturas de dados}

\subsection{Stack}
      De forma a evitar confusão na atribuição de \emph{labels} relativas a \emph{ifs} e \emph{loops} é utilizado um contador de condições. À medida que é encontrada uma instrução que implique o uso de uma condição, este contador é incrementado e o seu valor é colocado numa stack. Deste modo, o valor que se encontra no topo da stack é relativo ao último \emph{ciclo/if} encontrado. Sempre que é encontrado o final de uma condição, o valor no topo da stack é removido. Através do uso de um contador e de uma stack, é muito mais simples gerir as \emph{labels} e as operações de controlo, como \emph{JUMPs} e \emph{JZs}.
      A stack utilizada implementa apenas as funções necessárias para a sua inicialização, inserção, remoção e consulta. Com as operações de push/pop são inseridos/removidos valores no topo da stack, e com a operação de get, apenas é consultado o valor no topo da stack, sem que este seja removido. Esta última operação é útil para a geração de instruções 'JZ' na geração de código VM.

\subsection{HashMap}
	Como foi referido anteriormente, é utilizada uma hashmap com o objetivo de guardar as variáveis e as funções. Quanto às variáveis, é necessário guardar informação como o seu endereço e tipo. Sendo assim, foi criada uma estrutura de dados auxiliar para armazenar essa informação. O nome da variável é utilizado como chave e, a partir dela, conseguimos aceder à sua informação correspondente na hashmap. 


\chapter{Compilador}


\section{Analisador léxico}
  O analisador léxico construido deteta todos os símbolos terminais da linguagem (palavras reservadas, sinais e variáveis).
  É de se destacar a deteção de comentários, que são ignorados.
  De forma a que fosse mais fácil detetar os erros de sintaxe, o parser conta as linhas que já interpretou. Desta forma o analisador sintático quando dá erro diz a linha onde o erro aconteceu.  
  Para passar valores como o nome de variaveis ou números utiliza-se o yylval.


\section{Analisador sintatico/semantico}

As funções são declaras depois das variáveis globais para as funções terem acesso às variáveis globais.

\section{Geração de codigo máquina}
    A cada regra da gramática, associamos acções a serem executadas à medida que estas são reconhecidas. Assim sendo, é feita uma tradução da linguagem desenvolvida para a linguagem \emph{assembly} da VM, à medida que cada instrução ou expressão é identificada. A maioria destas acções implica uma instrução de escrita no ficheiro de output. Todas estas acções que implicam escrita no ficheiro são triviais, existindo apenas algumas excepções como o caso do ciclo 'for'.
	No ciclo 'for', foi necessária a utilização de instruções 'JUMP', de forma a ser possível seguir o seu fluxo de execução normal. Após a identificação e execução das acções associadas à expressão lógica presente no ciclo 'for', é gerado o salto condicional respectivo, assim como um salto para as instruções associadas ao corpo do ciclo. Além disso, é gerada uma \emph{label} que irá corresponder ao incremento do ciclo que irá ser identificado de seguida. Identificado o final do corpo do ciclo, é feito um salto para a \emph{label} correspondente ao incremento do ciclo, que para além das respetivas instruções, conterá outro 'JUMP' para o teste da expressão lógica.

\subsection{Funções}

Para a implementação de funções existiram algumas implicações que tiveram que ter ser resolvidas, teve-se que passar a lidar com mais do que um contexto, ou seja as variáveis podem ser globais ou locais.

As declarações das funções vem logo após às declarações das variáveis globais para que dentro das funções já se possa aceder às variáveis globais.

As declarações de variáveis são feitas no inicio da função, e no hash table das variáveis guarda-se não só o endereço mas também o contexto (ou seja se é local ou global). Com isto nos acessos ás variáveis utiliza-se 'PUSHG' ou 'PUSHL' mediante seja respetivamente variável global ou local.

A passagem de argumentos para a função é tratada como uma declaração especial em que o endereço é negativo.
Já o retorno da função é colocado também num endereço negativo que foi previamente alocado na chamada da função.

Para perceber melhor vamos utilizar um exemplo, assumindo que estamos a chamar uma função com 2 argumentos.
Como podemos ver na figura \ref{fig:functionStack}, os endereços são negativos ao fp, e o endereço onde a função colocará o retorno é $fp - 3$.
Após a execução da função é feito o 'pop' dos argumentos e assim o valor de retorno da função está no topo da stack. 

\begin{figure}
\centering
\includegraphics[width=5cm]{functionStack.png}
\caption{Chamada de uma função}
\label{fig:functionStack}
\end{figure}

\chapter{Testes}
\subsection{Teste 1}
\subsubsection{Input}
\subsubsection{Output}


\subsection{Teste 2}
\subsubsection{Input}
\subsubsection{Output}



\subsection{Teste 3}
\subsubsection{Input}
\subsubsection{Output}


\subsection{Teste 4}
\subsubsection{Input}
\lstinputlisting[language=c]{anexos/t4.in}
\subsubsection{Output}
\lstinputlisting[language=c]{anexos/t4.out}

\subsection{Teste 5}
\subsubsection{Input}
\lstinputlisting[language=c]{anexos/t5.in}
\subsubsection{Output}
\lstinputlisting[language=c]{anexos/t5.out}


\chapter{Conclusão}
\label{cap:intro}



\end{document}


% respectivo enunciado, da descricao do problema, das decisoes que lideraram o desenho da solucao e sua implementacao (incluir a especificacao Flex , deverao conter exemplos de utilizacao (textos fontes diversos e respectivo resultado produzido)