\documentclass[a4paper,10pt]{report}

\usepackage{graphicx}
\usepackage{color}

\usepackage{caption}
\usepackage{subcaption}

\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{geometry}
\geometry{a4paper}
\usepackage[parfill]{parskip}

\usepackage{changepage}

\usepackage{amsmath}

\usepackage{fancyhdr}

\usepackage{nopageno}

\graphicspath{{./imagens/}}

\usepackage{url}

\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{float}

\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue]{hyperref}


\lstset{
    extendedchars=\true,
    inputencoding=utf8
}

\renewcommand{\lstlistingname}{Código}
\usepackage{color}
\definecolor{grey}{rgb}{0.9,0.9,0.9}
\definecolor{greyD}{rgb}{0.5,0.5,0.5}

\lstnewenvironment{code}[1][]%
{
   \noindent
   \lstset{
  float=htpb,
  backgroundcolor=\color{grey},
  basicstyle=\scriptsize,
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{greyD},
  breaklines=true,
  frame=single,
  #1}
}
{}

\begin{document}

\include{capa}

\begin{abstract}
Este relatório descreve a resolução de um conjunto de exercícios propostos, que consistem no desenvolvimento de programas na linguagem C com o auxílio de geradores de filtros de texto, como o Flex. Para cada problema é realizada uma breve análise sobre o trabalho efetuado, as decisões que lideraram o seu desenvolvimento e as estruturas implementadas, assim como uma explicação do seu funcionamento. 

Os problemas resolvidos consistem no desenvolvimento de filtros de texto que:
\begin{itemize}
\item processa um ficheiro XML com descrições de fotografias e gera um álbum HTML.
\item processa de um ficheiro XML anotado com tags Enamex e gera páginas HTML apresentando as "pessoas", "países", "cidades" e organizações nele identificadas. 
\item processa vários ficheiros de texto, compostos por letras de canções, e gera documentos em LATEX para cada uma delas.
\end{itemize}
Para cada problema é apresentado o código em linguagem C e as expressões regulares desenvolvidas, sendo estes suportados por exemplos e devidos resultados.
\end{abstract}
%----------------------------------------------------------------------
%\newpage
%\phantom{placeholder} % doesn't appear on page
%\thispagestyle{empty} % if want no header/footer
%----------------------------------------------------------------------
\tableofcontents
%\phantom{placeholder} % doesn't appear on page
\thispagestyle{empty} % if want no header/footer
%----------------------------------------------------------------------
%\newpage
%\phantom{placeholder} % doesn't appear on page
%\thispagestyle{empty} % if want no header/footer
%----------------------------------------------------------------------
%\pagestyle{fancy}
%\setlength{\headheight}{15.2pt}
%\fancyhf{} % apagar as configurações actuais
%\fancyfoot[LE,RO]{\thepage}
%\fancyhead[LE,RO]{PL - Trabalho Pratico 1 --- Araujo P., Belo O., Oliveira R.}
%\page{setcounter}{0}
%----------------------------------------------------------------------

\chapter{Introdução}
\label{cap:intro}
O presente trabalho enquadra-se na unidade curricular de Processamento de Linguangens da Licenciatura em Engenharia Informática da Universidade do Minho. O trabalho pretende aumentar a experiência em engenharia de linguagens, 

\section{Linguagem de programação imperativa simples}
    Previamente ao desenvolvimento do compilador existe a necessidade de definir uma linguagem sobre a qual este atua, com base numa qualquer linguagem imperativa. Neste sentido e por simplicidade e familiaridade, a linguagem de programação C é a selecionada. Esta linguagem foi simplificada por forma a adaptar-se aos requisitos propostos, sofrendo as seguinte modificações na sua estrutura:

    - Apenas permite manusear variáveis do tipo inteiro (escalar ou array).
    - Suporta apenas as instruções vulgares de controlo de fluxo de execução (condicional e cíclica), tais como if-else, for, while e do-while.
    - As instruções que controlam inserção e output de valores (tipicamente printf e scanf) estão adaptadas para suportar apenas inteiros, e então estão renomeadas (printi e scani).
    - As expressões lógicas devem estar rodeadas por parentises para facilitar a sua distinção e ordem quando em conjunto com expressões aritméticas. 


    <Programa exemplo (programa exemplo que mostre de forma simples todas as funcionalidades - funçoes, atribuiçoes, ciclos, expressoes logicas e aritmeticas)> 

\section{Arquitetura}
    O sistema desenvolvido é principalmente constituído por 2 modelos:  parser.l, compiler.y, que são respetivamente o analisador léxico e analisador sintático. 

    Na Figura \ref{fig:dependencias}, podemos observar as dependências entre os ficheiros.

    O analisador sintático utiliza o ficheiro vmCompiler.h, sendo que este o modulo responsável pelo tratamento das variáveis e funções existentes (adicionar/consultar variáveis).

    O Sistema utiliza também duas estruturas de dados: uma HashMap e uma Stack. A hashmap é utilizada respetivamente para guardar as variáveis e as funções, enquanto que a stack permite o controlo das labels dos ciclos durante a compilação.

    Na figura \ref{fig:struct} é possível observar as estruturas utilizadas em vmCompiler:
    \begin{itemize}
      \item Scope - possuem uma map com a informação das variáveis, onde a chave é nome da variável e o valor é um EntryVar;
      \item EntryFun - guarda a informação sobre o tipo de uma função (argumentos de entrada e tipo de retorno);
      \item EntryVar - guarda o tipo, nome o endereço relativo de uma dada variável;
    \end{itemize}

    Com as estruturas anteriores em mente, as variáveis criadas em vmCompiler são as representadas na figura \ref{fig:objs}, onde se podem ver duas variáveis do tipo Scope, uma para o contexto global e outra para o contexto interior a uma função.

    Existe um map de EntryFun (mFuncMap) onde a chave é o nome da função.
    
    A variável DecFunAux consiste num apontador temporário para uma função declarada.

\begin{figure}
\centering
\includegraphics[width=15cm]{imagens/dependecias.png}
\caption{Diagrama das pedendencias dos ficheiros}
\label{fig:dependencias}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=10cm]{imagens/estruturas.jpg}
\caption{Diagrama das estruturas usadas em vmCompiler}
\label{fig:struct}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=10cm]{imagens/objetos.jpg}
\caption{Diagrama dos objetos existente em vmCompiler}
\label{fig:objs}
\end{figure}



\section{Estruturas de dados}

\subsection{Stack}
      De forma a evitar confusão na atribuição de \emph{labels} relativas a \emph{ifs} e \emph{loops} é utilizado um contador de condições. À medida que é encontrada uma instrução que implique o uso de uma condição, este contador é incrementado e o seu valor é colocado numa stack. Deste modo, o valor que se encontra no topo da stack é relativo ao último \emph{ciclo/if} encontrado. Sempre que é encontrado o final de uma condição, o valor no topo da stack é removido. Através do uso de um contador e de uma stack, é muito mais simples de gerir as \emph{labels} e as operações de controlo, como \emph{JUMPs} e \emph{JZs}.

\subsection{HashMap}



\chapter{Compilador}


\section{Analisador léxico}
  O analisador léxico construido deteta todos os símbolos terminais da linguagem (palavras reservadas, sinais e variáveis).
  É de se destacar a deteção de comentários, que são ignorados.
  De forma a que fosse mais fácil detetar os erros de sintaxe, o parser conta as linhas que já interpretou. Desta forma o analisador sintático quando dá erro diz a linha onde o erro aconteceu.  
  Para passar valores como o nome de variaveis ou números utiliza-se o yylval.


\section{Analalisador sintatico/semantico}

\section{Geração de codigo máquina}
    A cada regra da gramática, associamos acções a serem executadas à medida que estas são reconhecidas. Assim sendo, é feita uma tradução da linguagem desenvolvida para a linguagem \emph{assembly} da VM, à medida que cada instrução ou expressão é identificada. A maioria destas acções implica uma instrução de escrita no ficheiro de output. 


\chapter{Testes}


\chapter{Conclusão}
\label{cap:intro}



\include{anexos}
\end{document}


% respectivo enunciado, da descricao do problema, das decisoes que lideraram o desenho da solucao e sua implementacao (incluir a especificacao Flex , deverao conter exemplos de utilizacao (textos fontes diversos e respectivo resultado produzido)