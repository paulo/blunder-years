\documentclass[a4paper,10pt]{report}

\usepackage{graphicx}
\usepackage{color}

\usepackage{caption}
\usepackage{subcaption}

\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{geometry}
\geometry{a4paper}
\usepackage[parfill]{parskip}

\usepackage{changepage}

\usepackage{amsmath}

\usepackage{fancyhdr}

\usepackage{nopageno}

\graphicspath{{./imagens/}}

\usepackage{url}

\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{float}

\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue]{hyperref}


\lstset{
    extendedchars=\true,
    inputencoding=utf8
}

\renewcommand{\lstlistingname}{Código}
\usepackage{color}
\definecolor{grey}{rgb}{0.9,0.9,0.9}
\definecolor{greyD}{rgb}{0.5,0.5,0.5}

\lstnewenvironment{code}[1][]%
{
   \noindent
   \lstset{
  float=htpb,
  backgroundcolor=\color{grey},
  basicstyle=\scriptsize,
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{greyD},
  breaklines=true,
  frame=single,
  #1}
}
{}

\begin{document}

\include{capa}

\begin{abstract}
Este relatório descreve o desenvolvimento de um compilador para uma linguagem de programação imperativa simples (LPIS). 

A linguagem desenvolvida foi baseada na linguagem de programação C, e suporta:
\begin{itemize}
  \item Variáveis globais
  \item Ciclos: for, while, do while
  \item Estruturas de Condição: If .. Else
  \item Expressões Aritméticas e lógicas
  \item Funções com argumentos
  \item Declaração de variáveis locais dentro das funções
\end{itemize}
O compilador foi desenvolvido com recurso ao analisador léxico Flex e ao analisador sintático Yacc.

\end{abstract}
%----------------------------------------------------------------------
%\newpage
%\phantom{placeholder} % doesn't appear on page
%\thispagestyle{empty} % if want no header/footer
%----------------------------------------------------------------------
\tableofcontents
%\phantom{placeholder} % doesn't appear on page
\thispagestyle{empty} % if want no header/footer
%----------------------------------------------------------------------
%\newpage
%\phantom{placeholder} % doesn't appear on page
%\thispagestyle{empty} % if want no header/footer
%----------------------------------------------------------------------
%\pagestyle{fancy}
%\setlength{\headheight}{15.2pt}
%\fancyhf{} % apagar as configurações actuais
%\fancyfoot[LE,RO]{\thepage}
%\fancyhead[LE,RO]{PL - Trabalho Pratico 1 --- Araujo P., Belo O., Oliveira R.}
%\page{setcounter}{0}
%----------------------------------------------------------------------

\chapter{Introdução}
\label{cap:intro}
O presente trabalho enquadra-se na unidade curricular de Processamento de Linguangens da Licenciatura em Engenharia Informática da Universidade do Minho. O trabalho pretende aumentar a experiência em engenharia de linguagens, e motivar a utilização de ferramentas de compilação de compiladores e análise léxica.

Para isso era pretendido criar uma linguagem de programação imperativa simples, que será descrita à frente.
O compilador desta linguagem foi desenvolvido desde a analise léxica até à geração de código. O Código gerado foi assembly para a maquina virtual fornecida por o docente.


\section{Linguagem de programação imperativa simples}
    Previamente ao desenvolvimento do compilador existe a necessidade de definir uma linguagem sobre a qual este atua, com base numa qualquer linguagem imperativa. Neste sentido e por simplicidade e familiaridade, a linguagem de programação C é a selecionada. Esta linguagem foi simplificada por forma a adaptar-se aos requisitos propostos, sofrendo as seguinte modificações na sua estrutura:

    - Apenas permite manusear variáveis do tipo inteiro (escalar ou array).
    - Suporta apenas as instruções vulgares de controlo de fluxo de execução (condicional e cíclica), tais como if-else, for, while e do-while.
    - As instruções que controlam inserção e output de valores (tipicamente printf e scanf) estão adaptadas para suportar apenas inteiros, e então estão renomeadas (printi e scani).
    - As expressões lógicas devem estar rodeadas por parentises para facilitar a sua distinção e ordem quando em conjunto com expressões aritméticas. 


    <Programa exemplo (programa exemplo que mostre de forma simples todas as funcionalidades - funçoes, atribuiçoes, ciclos, expressoes logicas e aritmeticas)> 

\section{Arquitetura}
    O sistema desenvolvido é principalmente constituído por 2 modelos:  parser.l, compiler.y, que são respetivamente o analisador léxico e analisador sintático. 

    Na Figura \ref{fig:dependencias}, podemos observar as dependências entre os ficheiros.

    O analisador sintático utiliza o ficheiro vmCompiler.h, sendo que este o modulo responsável pelo tratamento das variáveis e funções existentes (adicionar/consultar variáveis).

    O Sistema utiliza também duas estruturas de dados: uma HashMap e uma Stack. A hashmap é utilizada respetivamente para guardar as variáveis e as funções, enquanto que a stack permite o controlo das labels dos ciclos durante a compilação.

    Na figura \ref{fig:struct} é possível observar as estruturas utilizadas em vmCompiler:
    \begin{itemize}
      \item Scope - possuem uma map com a informação das variáveis, onde a chave é nome da variável e o valor é um EntryVar;
      \item EntryFun - guarda a informação sobre o tipo de uma função (argumentos de entrada e tipo de retorno);
      \item EntryVar - guarda o tipo, nome o endereço relativo de uma dada variável;
    \end{itemize}

    Com as estruturas anteriores em mente, as variáveis criadas em vmCompiler são as representadas na figura \ref{fig:objs}, onde se podem ver duas variáveis do tipo Scope, uma para o contexto global e outra para o contexto interior a uma função.

    Existe um map de EntryFun (mFuncMap) onde a chave é o nome da função.
    
    A variável DecFunAux consiste num apontador temporário para uma função declarada.

\begin{figure}
\centering
\includegraphics[width=15cm]{imagens/dependecias.png}
\caption{Diagrama das pedendencias dos ficheiros}
\label{fig:dependencias}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=10cm]{imagens/estruturas.jpg}
\caption{Diagrama das estruturas usadas em vmCompiler}
\label{fig:struct}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=10cm]{imagens/objetos.jpg}
\caption{Diagrama dos objetos existente em vmCompiler}
\label{fig:objs}
\end{figure}



\section{Estruturas de dados}

\subsection{Stack}
      De forma a evitar confusão na atribuição de \emph{labels} relativas a \emph{ifs} e \emph{loops} é utilizado um contador de condições. À medida que é encontrada uma instrução que implique o uso de uma condição, este contador é incrementado e o seu valor é colocado numa stack. Deste modo, o valor que se encontra no topo da stack é relativo ao último \emph{ciclo/if} encontrado. Sempre que é encontrado o final de uma condição, o valor no topo da stack é removido. Através do uso de um contador e de uma stack, é muito mais simples gerir as \emph{labels} e as operações de controlo, como \emph{JUMPs} e \emph{JZs}.
      A stack utilizada implementa apenas as funções necessárias para a sua inicialização, inserção, remoção e consulta. Com as operações de push/pop são inseridos/removidos valores no topo da stack, e com a operação de get, apenas é consultado o valor no topo da stack, sem que este seja removido. Esta última operação é útil para a geração de instruções 'JZ' na geração de código VM.

\subsection{HashMap}
	Como foi referido anteriormente, é utilizada uma hashmap com o objetivo de guardar as variáveis e as funções. Quanto às variáveis, é necessário guardar e aceder a informação como o seu endereço e tipo. Sendo assim, foi criada uma estrutura de dados auxiliar para armazenar essa informação. O nome da variável é utilizado como chave e, a partir dela, conseguimos aceder à sua informação correspondente na hashmap. 
	Relativamente às funções, é necessário guardar e aceder a informação como o seu nome, informação relativa aos seus argumentos de entrada e o tipo de dados de saída. Para esse feito, também foram necessárias estruturas de dados auxiliares como uma lista ligada capaz de armazenar informação relativa aos argumentos de entrada e uma outra que contem a informação relativa ao tipo de dados de saída, dados de entrada e nome da função. Neste caso, o nome da função funciona como chave na hashmap e o seu valor é a estrutura que contem a informação mais geral sobre a função.
	A hashmap utilizada implementa funções necessárias para a sua inicialização, inserção, remoção e consulta, sendo que também contem outras funções que não foram utilizadas no desenvolvimento deste projeto.


\chapter{Compilador}


\section{Analisador léxico}
  O analisador léxico encontra-se desenvolvido com o suporte da ferramenta 'ylex' e deteta todos os símbolos terminais da linguagem (palavras reservadas, sinais e variáveis). Este analisador efetua também a deteção de comentários (linhas precedidas pelos símbolos '//'), ignorando o texto neles contidos. De forma a facilitar a deteção os erros de sintaxe, o parser conta as linhas que já interpretou. Este funcionalidade permite ao analisador sintático informar a linha onde ocorrer a anomalia em caso de erro de processamento. A passagem de valores é efetuada através do yylval.  

\section{Analisador sintatico/semantico}

As funções são declaradas depois das variáveis globais para as funções terem acesso às variáveis globais.

<erro de compilaçao nao tem problema pq fazer o shift por default é que é o necessario fazer>


\section{Geração de codigo máquina}
    A cada regra da gramática, associamos acções a serem executadas à medida que estas são reconhecidas. Assim sendo, é feita uma tradução da linguagem desenvolvida para a linguagem \emph{assembly} da VM, à medida que cada instrução ou expressão é identificada. A maioria destas acções implica uma instrução de escrita no ficheiro de output. Todas estas acções que implicam escrita no ficheiro são triviais, existindo apenas algumas excepções como o caso do ciclo 'for'.
	No ciclo 'for', foi necessária a utilização de instruções 'JUMP', de forma a ser possível seguir o seu fluxo de execução normal. Após a identificação e execução das acções associadas à expressão lógica presente no ciclo 'for', é gerado o salto condicional respectivo, assim como um salto para as instruções associadas ao corpo do ciclo. Além disso, é gerada uma \emph{label} que irá corresponder ao incremento do ciclo que irá ser identificado de seguida. Identificado o final do corpo do ciclo, é feito um salto para a \emph{label} correspondente ao incremento do ciclo, que para além das respetivas instruções, conterá outro 'JUMP' para o teste da expressão lógica.

\subsection{Funções}

Para a implementação de funções existiram algumas implicações que tiveram que ter ser resolvidas, teve-se que passar a lidar com mais do que um contexto, ou seja as variáveis podem ser globais ou locais.

As declarações das funções vem logo após às declarações das variáveis globais para que dentro das funções já se possa aceder às variáveis globais.

As declarações de variáveis são feitas no inicio da função, e no hash table das variáveis guarda-se não só o endereço mas também o contexto (ou seja se é local ou global). Com isto nos acessos ás variáveis utiliza-se 'PUSHG' ou 'PUSHL' mediante seja respetivamente variável global ou local.

A passagem de argumentos para a função é tratada como uma declaração especial em que o endereço é negativo.
Já o retorno da função é colocado também num endereço negativo que foi previamente alocado na chamada da função.

Para perceber melhor vamos utilizar um exemplo, assumindo que estamos a chamar uma função com 2 argumentos.
Como podemos ver na figura \ref{fig:functionStack}, os endereços são negativos ao fp, e o endereço onde a função colocará o retorno é $fp - 3$.
Após a execução da função é feito o 'pop' dos argumentos e assim o valor de retorno da função está no topo da stack. 

\begin{figure}
\centering
\includegraphics[width=5cm]{functionStack.png}
\caption{Chamada de uma função}
\label{fig:functionStack}
\end{figure}

\chapter{Testes}
\subsection{Teste 1}
\subsubsection{Input}
\lstinputlisting[language=c]{anexos/t1.in}
\subsubsection{Output}
\lstinputlisting[language=c]{anexos/t1.out}


\subsection{Teste 2}
\subsubsection{Input}
\lstinputlisting[language=c]{anexos/t2.in}
\subsubsection{Output}
\lstinputlisting[language=c]{anexos/t2.out}



\subsection{Teste 3}
\subsubsection{Input}
\lstinputlisting[language=c]{anexos/t3.in}
\subsubsection{Output}
\lstinputlisting[language=c]{anexos/t3.out}


\subsection{Teste 4}
\subsubsection{Input}
\lstinputlisting[language=c]{anexos/t4.in}
\subsubsection{Output}
\lstinputlisting[language=c]{anexos/t4.out}

\subsection{Teste 5}
\subsubsection{Input}
\lstinputlisting[language=c]{anexos/t5.in}
\subsubsection{Output}
\lstinputlisting[language=c]{anexos/t5.out}


\chapter{Conclusão}
\label{cap:intro}

Finalizado o desenvolvimento do trabalho, é possível analisar o resultado final e o impacto que as diversas decisões tiveram sobre este. Um dos principais pontos positivos consiste na implementação do processamento e compilação de funções, sendo esta a funcionalidade mais trabalhosa e sobre a qual recaiu maior parte do tempo despendido. Relativamente a estas, de notar uma mudança na forma como estas foram implementadas. Anteriormente, a estrutura relativa ao armazenamento de dados de uma função possuía a capacidade de dar acesso às variáveis declaradas dentro do seu contexto, no entanto decidiu-se que esta funcionalidade era desnecessária para o funcionamento do compilador, sendo esta informação descartada. A implementação das expressões de controlo de execução possuíram também uma dificuldade acrescida, obrigando à utilização de estruturas de dados mais complexas, tais como hashmaps e stacks. Creemos ter alcançado os objetivos definidos aquando da proposta do trabalho, tendo desenvolvido um compilador capaz de processar uma LPIS, com a possibilidade de dar feedback sobre o código de input definido e criar o ficheiro com instruções em Assembly correspondentes.


\end{document}


% respectivo enunciado, da descricao do problema, das decisoes que lideraram o desenho da solucao e sua implementacao (incluir a especificacao Flex , deverao conter exemplos de utilizacao (textos fontes diversos e respectivo resultado produzido)