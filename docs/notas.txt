Data de entrega: 8 de Janeiro
Relatório até 6 páginas.

---

.Sistema transacional distribuido
.Armazena dados (saldo) de contas bancárias em múltiplos servidores e permite transferências atómicas.
.Deve permitir a reinicialização de cada um dos servidores a qualquer momento e reforçar serializabilidade.

#Cliente

.Escrito em java.
.Permite uma única operação: transferência entre duas contas.
    .Recebe 3 parâmetros (2 números de contas e uma quantidade).
    .Imprime a confirmação se a transferência for bem sucedida.
.O número de contas devem identificar facilmente o correspondente bank server.
    - 3 primeiros digitos para identificar o servidor, e o resto para identificar a conta dentro desse servidor

#Bank Server

.Escrito em java com uma base de dados Apache Derby.
    - https://db.apache.org/derby/
    - http://www.vogella.com/tutorials/ApacheDerby/article.html
    - http://mvnrepository.com/artifact/org.apache.derby
    - https://netbeans.org/kb/docs/ide/java-db.html
.Deve fornecer operações de deposito e levantamento numa interface Java RMI para clientes.
    - https://docs.oracle.com/javase/tutorial/rmi/
    - http://docs.oracle.com/javase/7/docs/technotes/guides/rmi/
    - https://docs.oracle.com/javase/tutorial/rmi/overview.html
.A concorrência dos pedidos de utilizadores deve ser gerida com threads.

#Transactional server

https://www.progress.com/jdbc/resources/tutorials/understanding-jta/distributed-transactions-and-the-transaction-manager
http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html (java persistence)

.Escrito em java -> deve usar um mecanismo de persistência de dados à nossa escolha para armazenar o log (p.e. um servidor de bases de dados em non-XA mode).
.Deve fornecer operações para o cliente poder iniciar e terminar transacções distribuidas e interfaces para os recursos.
.O mecanismo de comunicação e as primitivas de concorrência escolhidas para o servidor transacional devem ser brevemente justificadas no relatório.



#Apache Derby

Terminal do Apache Derby:
    rlwrap java org.apache.derby.tools.ij (pq o terminal e um bocado fraco)

Criar base de dados: (o codigo sql é do tipo do postgres)
    connect 'jdbc:derby:~/Dropbox/MIEI/ParadigmasdeSistemasDistribuidos/TP2/testDB;create=true';
    show tables in app;

Ligar servidor:
    startNetworkServer -p 3301 



##Notas

- Penso que seja um base de dados em cada bank porque tenho aqui uma nota a dizer que as contas são criadas com um populate e que cada bank tem contas diferentes.

- a transaction schedule is serializable if its outcome (e.g., the resulting database state) is equal to the outcome of its transactions executed serially, i.e., sequentially without overlapping in time.

- O que é o non-XA mode.
    - O XA mode permite as transacções em 2PC. non-XA mode é basicamente uma tabela da base de dados onde vao ser guardados os logs. Serializable também dá, mas a tabela simplifica muito a vida.
- Formato do log, o que deve ser feito com o log, redo-log/undo-log?
    - O log é basicamente a info dos participantes da transacção (ter em conta que isto vai ser 2PC e por isso deve ser mantida a informação em caso de falhar do servidor de transacções). Quando é requisitada a transacção ao servidor de transacçoes, este guarda a informação dos recursos (máquinas) e quando a transição acaba e o servidor recebe a confirmação de ambos os recursos, a entrada no log é apagada.
    Formato: O nome do participante, onde o encontrar, em que transacção esta a participar. (EmbeddedDataSource: nomes, endereço, xid)

    EmbeddedXADataSource: logica de negócio



##Dúvidas tiradas com o prof

> Boa noite professor. Estou com algumas dúvidas referentes à
> implementação do trabalho prático que gostaria de ver esclarecidas.
> 
> 1) O cliente será uma implementação simples que apenas permite a
> execução dos comandos referidos com a passagem de todos os argumentos
> (incluindo o número da própria conta cada vez que quer efetuar um
> depósito), ou é necessário o registo da informação de estes clientes
> (requerendo a autenticação destes, etc)? Isto é, tem de haver algum
> tipo de sessão do lado do cliente?

Não é precisa qualquer identificação ou autenticação.

> 2) Entendi que o cliente deva efetuar comunicação com o transaction
> server para a operação de transacção e diretamente com os bank
> servers para as operações de levantamento e depósito (corrija-me se
> errado). A minha ideia seria implementar o transaction server
> utilizando a tecnologia de EJB + Java Transaction API, e o cliente e
> bank servers utilizando EJB + Java RMI (penso que o relatório obriga
> à implementação obrigatória de uma interface Java RMI para a
> comunicação entre cliente e bank servers). A minha linha de
> pensamento está correcta?

Atenão! O enunciado pede-lhes que implementem um servidor transacional
simples, não lhes pede que usem um servidor transacional existente no
Java EE.

> 3) A matéria da última aula (Message Driven Beans) tomará parte no
> projeto (visto ter sido leccionada sem exemplo prático)?

Não.

> 4) Só para confirmar, a execução de transacções deve ser executada
> através de 2PC?

Sim.

> 5) No enunciado refere que o transaction server deve fornecer ao
> cliente a capacidade de terminar transacções distribuídas. É suposto
> o cliente poder cancelar a transacção se esta estiver a demorar
> muito? Poderia explicar melhor este conceito?
> 

"Terminar uma transação" significa executar a operação de commit() ou
rollback() depois de efetuadas as operações que a constituem. Não se
espera que interrompam assincronamente operações em curso.

> Desculpe professor, mais ainda estou um bocado confuso. Nós devemos
> utilizar EJB mas não utilizar um servidor transacional existente no
> Java EE? Ou simplesmente a utilização de EJB não é aconselhada e
> devemos implementar tudo com Java RMI?


O enunciado não refere nem JavaEE nem EJB. Apenas pede que as operações
correspondentes à logica de negócio (entre o cliente e o servidor do
banco) sejam feitas com RMI. Em relação à comunicação entre o servidor
transacional e os outros componentes, pede-se que escolham o mecanismo
mais adequado dos que estudaram, entre sockets, 0MQ, etc.

---


> -O Cliente tem que ter como disponível uma operação de transferência
> entre contas bancárias, é necessário comunicar com o Coordenador de
> Transações. Esta comunicação deverá ser feita com algum mecanismo
> especifico ? 

Esse mecanismo é à vossa escolha, desde sockets, 0MQ, ... ou mesmo RMI.
Devem escolher o que acharem mais adequado.

> -Nos Bank Servers tem que estar disponíveis operações de depósito e
> levantamento de dinheiro utilizando Java RMI. Estes pedidos são
> feitos pelo Cliente ?

Sim. O cliente faz um transferência através de um levantamento seguido
de um deposito dentro de uma só transação.

> -Como deverá ser feita a comunicação entre Coordenador de Transações
> e e BankServers ?

Mais uma vez, é à vossa escolha. O único mecanismo de comunicação que é
fixo é entre o cliente e os BankServers.

> -Cada BankServer irá ter uma BD com as contas ?

Sim. Na aula sugeri utilizarem o Apache Derby em modo embedded (através
de uma EmbeddedXADataSource) que arranca o servidor dentro da mesma
JVM, para vos facilitar o desenvolvimento e testes.

---


> Teremos de implementar 2-phase locking ou não, uma vez que é algo 
> usado pelas bases de dados locais aos Bank Servers? 
> 
> Outra questão relacionada com o locking tem a haver com o 2PC e a 
> ocupação de dados. Para garantir que os dados se encontram 
> consistentes enquanto duas transações executam simultaneamente, não 
> pode haver um prepare sobre um item de dados que já se encontre 
> ocupado. Qual será a melhor forma de implementar este passo? 

Ao usar a BD, ela implementará o 2PL. Por isso, não lhe vai acontecer 
este problema: duas txn em conflito nunca chegarão simultaneamente ao 
prepare, já que uma delas irá ficar bloqueada antes. 

> Mesmo garantindo uma boa implementação, pode ainda haver a ocorrência 
> de deadlocks quando tentamos mover da conta 1 para a conta 2 e, 
> simultaneamente, da conta 2 para a conta 1. Para evitar isto, podemos 
> implementar a transação geral realizando as operações pela ordem da 
> conta e não pela ordem levantamento -> depósito? 

Sim. Mas a BD também irá solucionar os deadlocks porque vai dar timeout 
e consequentemente uma exceção que deve levar ao rollback. 

> No enunciado o professor refere que "[bank servers should] enforce 
> serializability". O que se entende por isto? 

Que as transações executadas são equivalentes a uma sequência sem 
execução concorrente. Isso será garantido pelo 2PL+2PC. 

> É ainda referido que os bank servers devem fornecer uma API para 
> clientes que queiram fazer levantamentos e depósitos. Devemos 
> considerar que estes clientes são os consumidores da API e não os 
> clientes propriamente ditos? 

Não percebi esta duvida. Mas o programa cliente comunica com os bank 
servers para fazer a transferencia, efetuando um levantamento e um 
deposito. 

> Desta forma, no nosso entender, os clientes comunicariam com o 
> Transactional Server que coordenaria as ações entre os diversos Bank 
> Servers. 

Sim, o programa cliente também tem que comunicar com o coordenador de 
transações, para iniciar e terminar transações. 

> Por último, o professor refere a possibilidade de fazer restart aos 
> vários servidores. Devemos então implementar um mecanismo de redo- 
> logging caso a falha tenha ocorrido durante uma transação, correto? 

O mecanismo de logging é-lhe dado pelas bases de dados. Apenas precisa 
de implementar a coordenação desses logs através do 2PC.


> Não seria possível optar por uma arquitetura alternativa em que o
> cliente apenas comunica com o Transactional Server e indica os
> números das contas e o montante a transferir?
> 
> Desta forma, o Transactional Server terá uma thread por cliente e
> associará o número de conta ao banco correto, tratando assim de
> servir de coordenador da transação.
> 
> Na alternativa sugerida pelo prof não entendemos bem como o
> Transactional Server iria funcionar.

Nesse caso, o transactional server não seria middleware genérico, que
possa ser reutilizado com qualquer aplicação.

Veja por favor o slide em anexo, que detalha a interação em um client,
um gestor de transações e dois recursos, que neste caso serão os
servidores dos bancos. Lembra-se de o ter explicado na aula?



- Criar contexto é meter uma entrada no log com as cenas que vai receber?
- cada resource identifica-se a si proprio ao transServer?

Epifania:
- No inicio, o cliente vai criar um contexto no transServer. Isto significa simplesmente que vai dizer ao transServer que quer fazer uma transação. O transServer responde a dizer-lhe o id dessa transacção.
- De seguida, o cliente vai dizer a cada um dos recursos para se ligarem ao transServer. Isto transmite info ao transServer pq os recursos sabem qual é o id da transacção. Assim, no log do transServer, a informação para fazer a transação vai-se completando.
- Depois de fazer isso, o cliente vai dar sinal ao transServer para fazer commit da transação, sendo que este vai começar a fase 1 e a fase 2. Apenas aqui começa verdadeiramente o 2PC. No fim o transServer recebe a confirmação se correu bem ou mal.


#Explicação sobre o porquê de usar protobuffers

If you are 100% certain that the programs that are going to communicate over ZMQ will at all times be capable of understanding each other's binary format (eg because they are always distributed together and were all compiled with the same compiler options anyways) I see no benefit to the overhead that's added by serialization.

As soon as the above condition cannot be satisfied (like partner programs running on different host types, programs written in different languages or even partner programs that can evolve independently in time - which may cause incompatibilities in their raw binary structures) serialization becomes quite probably a must.

It seems that nowadays everybody and their brother is creating serialization solutions, which may be an indication that there's no one size fits all solution. This page contains a pretty thorough benchmarking of serialization time, deserialization time and sizes for 27 (!!) different serialization systems. Don't skip the first paragraph of that page, it says "Warning, benchmarks can be misleading". Your application, your data are what counts for you, but the data presented there may help you narrow down the choices you want to study in detail.
