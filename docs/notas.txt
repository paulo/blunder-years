Data de entrega: 8 de Janeiro
Relatório até 6 páginas.

---

.Sistema transacional distribuido
.Armazena dados (saldo) de contas bancárias em múltiplos servidores e permite transferências atómicas.
.Deve permitir a reinicialização de cada um dos servidores a qualquer momento e reforçar serializabilidade.

#Cliente

.Escrito em java.
.Permite uma única operação: transferência entre duas contas.
    .Recebe 3 parâmetros (2 números de contas e uma quantidade).
    .Imprime a confirmação se a transferência for bem sucedida.
.O número de contas devem identificar facilmente o correspondente bank server.
    - 3 primeiros digitos para identificar o servidor, e o resto para identificar a conta dentro desse servidor

#Bank Server

.Escrito em java com uma base de dados Apache Derby.
    - https://db.apache.org/derby/
    - http://www.vogella.com/tutorials/ApacheDerby/article.html
    - http://mvnrepository.com/artifact/org.apache.derby
    - https://netbeans.org/kb/docs/ide/java-db.html
.Deve fornecer operações de deposito e levantamento numa interface Java RMI para clientes.
    - https://docs.oracle.com/javase/tutorial/rmi/
    - http://docs.oracle.com/javase/7/docs/technotes/guides/rmi/
    - https://docs.oracle.com/javase/tutorial/rmi/overview.html
.A concorrência dos pedidos de utilizadores deve ser gerida com threads.

#Transactional server

https://www.progress.com/jdbc/resources/tutorials/understanding-jta/distributed-transactions-and-the-transaction-manager
http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html (java persistence)

.Escrito em java -> deve usar um mecanismo de persistência de dados à nossa escolha para armazenar o log (p.e. um servidor de bases de dados em non-XA mode).
.Deve fornecer operações para o cliente poder iniciar e terminar transacções distribuidas e interfaces para os recursos.
.O mecanismo de comunicação e as primitivas de concorrência escolhidas para o servidor transacional devem ser brevemente justificadas no relatório.



#Apache Derby

Terminal do Apache Derby:
    rlwrap java org.apache.derby.tools.ij (pq o terminal e um bocado fraco)

Criar base de dados: (o codigo sql é do tipo do postgres)
    connect 'jdbc:derby:~/Dropbox/MIEI/ParadigmasdeSistemasDistribuidos/TP2/testDB;create=true';
    show tables in app;

Ligar servidor:
    startNetworkServer -p 3301 



##Notas

- Penso que seja um base de dados em cada bank porque tenho aqui uma nota a dizer que as contas são criadas com um populate e que cada bank tem contas diferentes.

- a transaction schedule is serializable if its outcome (e.g., the resulting database state) is equal to the outcome of its transactions executed serially, i.e., sequentially without overlapping in time.

- O que é o non-XA mode.
    - O XA mode permite as transacções em 2PC. non-XA mode é basicamente uma tabela da base de dados onde vao ser guardados os logs. Serializable também dá, mas a tabela simplifica muito a vida.
- Formato do log, o que deve ser feito com o log, redo-log/undo-log?
    - O log é basicamente a info dos participantes da transacção (ter em conta que isto vai ser 2PC e por isso deve ser mantida a informação em caso de falhar do servidor de transacções). Quando é requisitada a transacção ao servidor de transacçoes, este guarda a informação dos recursos (máquinas) e quando a transição acaba e o servidor recebe a confirmação de ambos os recursos, a entrada no log é apagada.
    Formato: O nome do participante, onde o encontrar, em que transacção esta a participar. (EmbeddedDataSource: nomes, endereço, xid)

    EmbeddedXADataSource: logica de negócio



##Dúvidas tiradas com o prof

> Boa noite professor. Estou com algumas dúvidas referentes à
> implementação do trabalho prático que gostaria de ver esclarecidas.
> 
> 1) O cliente será uma implementação simples que apenas permite a
> execução dos comandos referidos com a passagem de todos os argumentos
> (incluindo o número da própria conta cada vez que quer efetuar um
> depósito), ou é necessário o registo da informação de estes clientes
> (requerendo a autenticação destes, etc)? Isto é, tem de haver algum
> tipo de sessão do lado do cliente?

Não é precisa qualquer identificação ou autenticação.

> 2) Entendi que o cliente deva efetuar comunicação com o transaction
> server para a operação de transacção e diretamente com os bank
> servers para as operações de levantamento e depósito (corrija-me se
> errado). A minha ideia seria implementar o transaction server
> utilizando a tecnologia de EJB + Java Transaction API, e o cliente e
> bank servers utilizando EJB + Java RMI (penso que o relatório obriga
> à implementação obrigatória de uma interface Java RMI para a
> comunicação entre cliente e bank servers). A minha linha de
> pensamento está correcta?

Atenão! O enunciado pede-lhes que implementem um servidor transacional
simples, não lhes pede que usem um servidor transacional existente no
Java EE.

> 3) A matéria da última aula (Message Driven Beans) tomará parte no
> projeto (visto ter sido leccionada sem exemplo prático)?

Não.

> 4) Só para confirmar, a execução de transacções deve ser executada
> através de 2PC?

Sim.

> 5) No enunciado refere que o transaction server deve fornecer ao
> cliente a capacidade de terminar transacções distribuídas. É suposto
> o cliente poder cancelar a transacção se esta estiver a demorar
> muito? Poderia explicar melhor este conceito?
> 

"Terminar uma transação" significa executar a operação de commit() ou
rollback() depois de efetuadas as operações que a constituem. Não se
espera que interrompam assincronamente operações em curso.

> Desculpe professor, mais ainda estou um bocado confuso. Nós devemos
> utilizar EJB mas não utilizar um servidor transacional existente no
> Java EE? Ou simplesmente a utilização de EJB não é aconselhada e
> devemos implementar tudo com Java RMI?


O enunciado não refere nem JavaEE nem EJB. Apenas pede que as operações
correspondentes à logica de negócio (entre o cliente e o servidor do
banco) sejam feitas com RMI. Em relação à comunicação entre o servidor
transacional e os outros componentes, pede-se que escolham o mecanismo
mais adequado dos que estudaram, entre sockets, 0MQ, etc.

---


> -O Cliente tem que ter como disponível uma operação de transferência
> entre contas bancárias, é necessário comunicar com o Coordenador de
> Transações. Esta comunicação deverá ser feita com algum mecanismo
> especifico ? 

Esse mecanismo é à vossa escolha, desde sockets, 0MQ, ... ou mesmo RMI.
Devem escolher o que acharem mais adequado.

> -Nos Bank Servers tem que estar disponíveis operações de depósito e
> levantamento de dinheiro utilizando Java RMI. Estes pedidos são
> feitos pelo Cliente ?

Sim. O cliente faz um transferência através de um levantamento seguido
de um deposito dentro de uma só transação.

> -Como deverá ser feita a comunicação entre Coordenador de Transações
> e e BankServers ?

Mais uma vez, é à vossa escolha. O único mecanismo de comunicação que é
fixo é entre o cliente e os BankServers.

> -Cada BankServer irá ter uma BD com as contas ?

Sim. Na aula sugeri utilizarem o Apache Derby em modo embedded (através
de uma EmbeddedXADataSource) que arranca o servidor dentro da mesma
JVM, para vos facilitar o desenvolvimento e testes.

---


> Teremos de implementar 2-phase locking ou não, uma vez que é algo 
> usado pelas bases de dados locais aos Bank Servers? 
> 
> Outra questão relacionada com o locking tem a haver com o 2PC e a 
> ocupação de dados. Para garantir que os dados se encontram 
> consistentes enquanto duas transações executam simultaneamente, não 
> pode haver um prepare sobre um item de dados que já se encontre 
> ocupado. Qual será a melhor forma de implementar este passo? 

Ao usar a BD, ela implementará o 2PL. Por isso, não lhe vai acontecer 
este problema: duas txn em conflito nunca chegarão simultaneamente ao 
prepare, já que uma delas irá ficar bloqueada antes. 

> Mesmo garantindo uma boa implementação, pode ainda haver a ocorrência 
> de deadlocks quando tentamos mover da conta 1 para a conta 2 e, 
> simultaneamente, da conta 2 para a conta 1. Para evitar isto, podemos 
> implementar a transação geral realizando as operações pela ordem da 
> conta e não pela ordem levantamento -> depósito? 

Sim. Mas a BD também irá solucionar os deadlocks porque vai dar timeout 
e consequentemente uma exceção que deve levar ao rollback. 

> No enunciado o professor refere que "[bank servers should] enforce 
> serializability". O que se entende por isto? 

Que as transações executadas são equivalentes a uma sequência sem 
execução concorrente. Isso será garantido pelo 2PL+2PC. 

> É ainda referido que os bank servers devem fornecer uma API para 
> clientes que queiram fazer levantamentos e depósitos. Devemos 
> considerar que estes clientes são os consumidores da API e não os 
> clientes propriamente ditos? 

Não percebi esta duvida. Mas o programa cliente comunica com os bank 
servers para fazer a transferencia, efetuando um levantamento e um 
deposito. 

> Desta forma, no nosso entender, os clientes comunicariam com o 
> Transactional Server que coordenaria as ações entre os diversos Bank 
> Servers. 

Sim, o programa cliente também tem que comunicar com o coordenador de 
transações, para iniciar e terminar transações. 

> Por último, o professor refere a possibilidade de fazer restart aos 
> vários servidores. Devemos então implementar um mecanismo de redo- 
> logging caso a falha tenha ocorrido durante uma transação, correto? 

O mecanismo de logging é-lhe dado pelas bases de dados. Apenas precisa 
de implementar a coordenação desses logs através do 2PC.


> Não seria possível optar por uma arquitetura alternativa em que o
> cliente apenas comunica com o Transactional Server e indica os
> números das contas e o montante a transferir?
> 
> Desta forma, o Transactional Server terá uma thread por cliente e
> associará o número de conta ao banco correto, tratando assim de
> servir de coordenador da transação.
> 
> Na alternativa sugerida pelo prof não entendemos bem como o
> Transactional Server iria funcionar.

Nesse caso, o transactional server não seria middleware genérico, que
possa ser reutilizado com qualquer aplicação.

Veja por favor o slide em anexo, que detalha a interação em um client,
um gestor de transações e dois recursos, que neste caso serão os
servidores dos bancos. Lembra-se de o ter explicado na aula?


> 1) Continuo sem entender a forma como os diversos componentes vão
> interagir. Nomeadamente:
>  A aplicação cliente vai interagir com os Bank Servers para
> fazer operações apenas de levantamento OU depósito? Segundo a minha
> ideia, e segundo o que está descrito nos slides fornecidos pelo
> professor sobre enterprise middleware (slide 48), a aplicação cliente
> é responsável por dizer aos bank serarvers que estes se devem
> apresentar ao transactional server, sendo que após todos os recursos
> se apresentarem ao transactional server, este procede à invocação  

A quem se refere o "este" nesta frase? Deve ser ao cliente, pois é ele
que invoca o levantamente e o deposito.

> remota dos métodos de depósito e levantamento nos respetivos bank
> servers de forma a efetuar a transacção. No entanto, em mails
> anteriores o professor deu a entender que a lógica da transação está
> na aplicação cliente e que esta seria a responsável por fazer a
> invocação remota dos métodos de depósito e levantamento. Pode dizer
> qual o caso a implementar?

O cliente invoca os métodos de depósito e levantamento nos servidores
dos bancos.

> Eu percebo a ideia de que o transactional server deve ser genérico,
> no entanto não me parece adequado a presença de tanta lógica de
> negócio no cliente. 
>
> Como é que estas bases de dados funcionam em termos de
> concorrência? Pode existir conflitos se diferentes threads tentarem
> aceder ao mesmo tempo ao mesmo item de dados ou elas permitem apenas
> acesso a uma thread de cada vez?
> 

As bases de dados fazem-lhe 2-phase locking. Garantem pois que não tem
mais do que um thread a aceder a cada linha (i.e. conta).

Recomendo que consulte a sec. 2.3.2 do livro "Web Services" (http://www
.springer.com/us/book/9783540440086) disponivel nos SDUM. (Verifiquei
que ainda não tinha a bibliografia no elearning. Acrescentei-a na
secção de conteúdo).


> Muito obrigado pela ajuda. Só ficamos com uma última dúvida, uma vez 
> que o professor tinha dito que o Transactional Server teria de ser 
> genérico e encaixar em qualquer aplicação, causou-nos um pouco de 
> confusão sobre a forma como os Bank Servers iriam registar as suas 
> transações no coordenador. 
> 
> Isto é, devemos considerar que teremos um TransactionalServer<T>
> extendsMovementIf>, sendo que MovementIf será uma classe que irá conter o c
> ódigo necessário para correr a transação (indicar se é levantamento ou 
> depósito, o número da conta, o montante e se existe saldo suficiente) e 
> gerar o SQL correspondente para o run ou 

Não. O que lhe é pedido é que implement 3 programas: o cliente do 
banco, o servidor do banco, e o servidor transacional. O servidor 
transacional não depende nem conhece de forma nenhuma da lógica da 
aplicação nem invoca quaisquer operações da lógica de negócio. 

Sugiro também que consulte a sec. 2.3.2 do livro "Web Services" (http:/ 
/www.springer.com/us/book/9783540440086) disponivel nos SDUM. 
(Verifiquei que ainda não tinha a bibliografia no elearning. 
Acrescentei-a na secção de conteúdo). 

> deveremos usar alguma classe da API de XA Transaction? 

Sim, precisa de usar a API em javax.transaction.xa como no exemplo da 
livraria que implementamos na aula, para fazer prepare() e depois 
commit() na base de dados. Recomendo que reveja os apontamentos e o 
código de exemplo da aula em que discutimos o 2PC. 

Cumprimentos,



> Surgiu uma dúvida no desenvolvimento do trabalho prático 2. Na 
> descrição do funcionamento de Two Phase Commit dos slides das aulas, 
> no caso de falha de um participante, é referido que se este tiver 
> votado (ou seja, se tiver informado o coordenador que se encontra 
> preparado) antes de haver a falha, após reiniciar deve esperar por 
> uma mensagem do coordenador (a mensagem COMMIT). Não será possível, 
> no entanto, que o coordenador tenha enviado a mensagem de COMMIT 
> enquanto o participante ainda estava desligado? Nesse caso, o 
> participante deveria contactar o coordenador? 

Pode optar por qualquer das alternativas. Ou o coordenador tenta 
repetidamente contactar o participante, até que finalmente consegue, ou 
então o participante contacta o coordenador quando reinicia, para 
descobrir se entretanto perdeu alguma mensagem.




- Criar contexto é meter uma entrada no log com as cenas que vai receber?
- cada resource identifica-se a si proprio ao transServer?









##Justificar o uso de rmi entre os bankservers e o transerver por dizer que facilita imenso a vida, tanto a guardar as cenas no log, como a tratar das conexões


#Explicação sobre o porquê de usar protobuffers

If you are 100% certain that the programs that are going to communicate over ZMQ will at all times be capable of understanding each other's binary format (eg because they are always distributed together and were all compiled with the same compiler options anyways) I see no benefit to the overhead that's added by serialization.

As soon as the above condition cannot be satisfied (like partner programs running on different host types, programs written in different languages or even partner programs that can evolve independently in time - which may cause incompatibilities in their raw binary structures) serialization becomes quite probably a must.

It seems that nowadays everybody and their brother is creating serialization solutions, which may be an indication that there's no one size fits all solution. This page contains a pretty thorough benchmarking of serialization time, deserialization time and sizes for 27 (!!) different serialization systems. Don't skip the first paragraph of that page, it says "Warning, benchmarks can be misleading". Your application, your data are what counts for you, but the data presented there may help you narrow down the choices you want to study in detail.

#Transaction context

The transaction context is a pseudo-object that is passed to the server object from the client, or from one server object to another, in the case where one server object is invoking methods on another, and hence acting as its client. The transaction context carries the state of the transaction.

After a client-side transaction service is initialized, and a begin transaction method is invoked, the transaction service implicitly creates a transaction context, and assigns a transaction ID number to the context. The client transaction service then propagates the transaction context to each participant in the transaction, that is, to each object that the client calls.

Propagation of the transaction context on each method invocation is normally transparent to the client program. The transaction context is maintained by the transaction service for each client. Transaction contexts are propagated transparently from the transaction initiator to the server object. On the client side, an interceptor is engaged to submit the transaction context on any method call to a server object. A server-side interceptor extracts the transaction context information, and makes it available to the server object.

As stated in "Limitations", a transaction context cannot span multiple sessions. Each new session connection requires a new transaction context.
